//
//  StyleKit.m
//  CircleAnimation
//
//  Created by 能登 要 on 2015/05/06.
//  Copyright (c) 2015 Irimasu Densan Planning. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "StyleKit.h"


@implementation StyleKit

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawCircleWithFrame: (CGRect)frame circleColor: (UIColor*)circleColor endAngle: (CGFloat)endAngle interactiveFrame: (CGRect)interactiveFrame brushWidth: (CGFloat)brushWidth
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    CGFloat circleColorHSBA[4];
    [circleColor getHue: &circleColorHSBA[0] saturation: &circleColorHSBA[1] brightness: &circleColorHSBA[2] alpha: &circleColorHSBA[3]];

    UIColor* circleColorBackground = [UIColor colorWithHue: circleColorHSBA[0] saturation: circleColorHSBA[1] brightness: 0.1 alpha: circleColorHSBA[3]];

    //// Variable Declarations
    CGFloat startAngle = 0;
    CGFloat circleStartAngle = startAngle + 90;
    CGFloat circleEndAngle = 90 - endAngle;
    CGFloat endEdgeTransformAngle = -endAngle;
    CGFloat circleOffsetValue = brushWidth * 0.735;
    CGRect cicleFrame = CGRectMake(interactiveFrame.origin.x + circleOffsetValue, interactiveFrame.origin.y + circleOffsetValue, interactiveFrame.size.width - circleOffsetValue * 2, interactiveFrame.size.height - circleOffsetValue * 2);
    CGRect startEdgeFrame = CGRectMake((interactiveFrame.size.width - brushWidth) * 0.5, circleOffsetValue - brushWidth * 0.5, brushWidth, brushWidth);
    CGRect endEdgeFrame = CGRectMake(interactiveFrame.size.width * 0.5, interactiveFrame.size.height * 0.5, brushWidth, brushWidth);
    CGPoint edgeTransformOffset = CGPointMake(-brushWidth * 0.5, -brushWidth * 0.5 - (interactiveFrame.size.height - brushWidth) * 0.5 + (circleOffsetValue - brushWidth * 0.5));

    //// Oval Drawing
    UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame) + 21.5, CGRectGetMinY(frame) + 21.5, CGRectGetWidth(frame) - 43, CGRectGetHeight(frame) - 43)];
    [circleColorBackground setStroke];
    ovalPath.lineWidth = brushWidth;
    [ovalPath stroke];


    //// Oval 2 Drawing
    CGRect oval2Rect = cicleFrame;
    UIBezierPath* oval2Path = UIBezierPath.bezierPath;
    [oval2Path addArcWithCenter: CGPointMake(CGRectGetMidX(oval2Rect), CGRectGetMidY(oval2Rect)) radius: CGRectGetWidth(oval2Rect) / 2 startAngle: -circleStartAngle * M_PI/180 endAngle: -circleEndAngle * M_PI/180 clockwise: YES];

    [circleColor setStroke];
    oval2Path.lineWidth = brushWidth;
    [oval2Path stroke];


    //// Oval 4 Drawing
    UIBezierPath* oval4Path = [UIBezierPath bezierPathWithOvalInRect: startEdgeFrame];
    [circleColor setFill];
    [oval4Path fill];


    //// Oval 3 Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, endEdgeFrame.origin.x, endEdgeFrame.origin.y);
    CGContextRotateCTM(context, -endEdgeTransformAngle * M_PI / 180);

    UIBezierPath* oval3Path = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(edgeTransformOffset.x, edgeTransformOffset.y, endEdgeFrame.size.width, endEdgeFrame.size.height)];
    [circleColor setFill];
    [oval3Path fill];

    CGContextRestoreGState(context);
}

@end
